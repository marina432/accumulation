### 一、幻读  
> 幻读指的是一个事务内，前后两次查询同一个范围的时候，后一次查询看到来前一次查询没有看到的行。  
>> 对于幻读有以下两点需要明确：  
>> 1. 在rr隔离级别下，普通的查询是一致性读，是不会看到其它事务插入的数据的。因此，幻读在"当前读"下才会出现。  
>> 2. 幻读仅专指（不该看到的）"新插入的行"。  

### 二、间隙锁Gap Lock（解决幻读问题）  
分析幻读产生读原因是：行锁只能锁住（现有的）数据行，而新插入记录这个动作，操作的对象是数据行间隙。因此，为了解决幻读问题，
Innodb只好引入了新读锁，也就是间隙锁（Gap Lock）。  
> 数据行是可以加上锁读实体，数据行之间读间隙也是可以加上锁的实体。  
> 行锁分为读锁与写锁，读锁与读锁兼容，而读锁与写锁、写锁与写锁之间冲突。  
> 间隙锁与间隙锁之间不存在冲突关系，跟间隙锁存在冲突关系的是"往这个间隙中插入记录"这个操作。即：间隙锁的作用就是保护这个间隙。  

> *关于rc+'binlog_format=row'组合：  
> 间隙锁在rr隔离级别下才会生效。如果将隔离级别设置为rc，为了解决可能出现的数据和日志不一致问题，需要将binlog格式
> 设置为row(即：binlog_format=ROW)。这也是目前不少公司使用的配置组合。  
>> 锁的设计是为了保证数据的一致性，而这个一致性，不只是数据库内部数据状态在此刻的一致性，还包含了数据和日志在逻辑上的一致性。

#### next-key lock  
> 间隙锁和行锁合称next-key lock，每个next-key lock都是前开后闭区间。  
>> 以"select * from t for update;"为例，全表扫描（即扫描聚簇索引），在聚簇索引上加了（记录数n+1）个next-key lock。 
>> 以"select * from t where 索引列=xxx for update;"为例，会在二级索引上xxx数据行左右两侧各加一个next-key lock。（当然如果没有命中xxx，就加一个包含
>> xxx在范围内的next-key lock） 

#### 引入间隙锁带来的问题  
- 导致锁住的范围更大，影响并发度。  
- 




Chapter 20/