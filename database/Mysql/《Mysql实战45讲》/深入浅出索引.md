### 一、三种常见的索引模型  
- 哈希表  
  哈希索引适用于只有等值查询到场景（如缓存，NoSQL引擎）；   
  不适用于做区间查询，速度很慢
- 有序数组（maybe也是算法喜欢考排序的原因，有一种说法：说排序是性价比最高的算法）  
  有序数组索引在等值查询和范围查询场景中的性能很好。（二分查找）  
  但是，这种索引只适用于静态存储引擎。因为它虽然查询新能很高，可在需要更新数据的时候就很麻烦了，挪动数据成本太高。
- 排序树  
  排序树索引中，以平衡二叉树AVL（一颗高度平衡的二叉查找树）的搜索效率最高。  
  但是，由于索引不仅存在内存中，还要写到磁盘上，因此为了尽量减少读磁盘的次数，我们使用"N"叉树（多路平衡查找树）。
  鉴于"N"叉树在读写上的性能优点，以及适配磁盘的访问方式，已经被广泛应用在数据库引擎中。  
  
> 目前，跳表、LSM树等数据结构也被用于存储引擎设计中。  
> 关于LSM树可参考阅读：https://zhuanlan.zhihu.com/p/181498475  
>> 数据库底层存储等核心就是基于这些数据类型的。每碰到一个数据库，我们需要先关注他的数据模型，这样才能从理论上分析出这个数据库的适用场景。  



### 二、InnoDB的索引模型-B+树  
> 索引组织表：在InnoDB中，表都是根据主键顺序以索引的方式存放的，这种存储方式的表称为索引组织表。  
>> 即：虽然MyISAM和InnoDB都是使用B+树作为索引，但是，二者的具体实现方式却截然不同：
>> - InnoDB中为索引组织表，数据存储在B+树索引中（确切说是存储在聚簇索引中）。 而在MyISAM中，数据和索引是分开存放的，叶子节点中的data存储的是数据存放地址。（可参考阅读：https://www.yuque.com/mona432/oxsztl/gpx09o/edit）  

#### 2.1 两种索引
- 聚簇索引（亦"主键索引"） 
  1. 如果定义来pk，则pk就是聚簇索引。  
  2. 如果没有定义pk，则第一个not null unique列是聚簇索引。  
  3. 如果以上都没有，那么InnoDB会创建一个隐藏都row-id作为聚簇索引。（这一点跟oracle类似）  
  > 由于聚簇索引都叶子节点存储都是行数据，所以，使用其检索数据非常快。
- 二级索引（亦"非主键索引"）  
  二级索引的叶子节点存储的是主键值。所以使用二级索引检索数据，"可能"需要回表。
  > ps：如果发生索引覆盖，就无需回表了，因此，这里用的是"可能"。
> 有关回表、索引覆盖可参看：https://www.yuque.com/mona432/vreg8d/bpm5lb  

#### 2.2 索引维护  
- 页分裂（无序插入导致） 
- 页合并（删除操作导致）  
> 有些建表规范明确要求建表语句里一定要有"自增"主键（建议使用bigint unsigned），就是为了避免"页分裂"，从而避免写成本太高。  
> 注：业务字段从两方面考虑不适合做主键：  
> - 从业务属性来看，不容易保证有序插入，进而无法避免"页分裂"；
> - 从存储空间角度来看，由于每个二级索引的叶子节点上存储的都是主键值，显然，主键长度越小，二级索引的叶子节点就越小，
> 二级索引占用的空间也就越小。 
>> 当然，又有例外，比如典型的KV场景就适合用业务字段直接做主键，比如有些长江要求：  
>> - 只有一个索引。（由于没有其它索引，也就不用考虑上面提到的存储空间问题，当然"页分裂"还是不可避免的）
>> - 该索引必须是唯一索引。  
















