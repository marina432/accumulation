参考：https://blog.csdn.net/Bill_82/article/details/108455018





### 1. Redis分布式锁解决方案  
主要围绕加锁、解锁、锁超时  
1. 基于Redis单机的分布式锁方案：  
- setnx + expire  --锁超时问题：两个原子操作命令组合使用形成非原子操作，存在锁永远无法释放问题  
- 使用SET扩展指令（set key value nx ex/px）  --锁续命问题：加锁段为执行完，但锁提前超时释放，造成：1.其它线程提前获取到锁，发生并行；2.本线程加锁段执行完后，释放其它并行线程到锁。  
> 针对错误地释放其它线程锁的问题解决方案：
> 具体实现就是在加锁时将 value 设置为一个唯一的随机数（或者线程 ID ），释放锁时先判断随机数是否一致，然后再执行释放操作，确保不会错误地释放其它线程持有的锁，除非是锁过期了被服务器自动释放。  
> 不过，判断 value 和删除 key 是两个独立的操作，并不是原子性的，所以这个地方需要使用 Lua 脚本进行处理，因为 Lua 脚本可以保证连续多个指令的原子性执行。  
- 使用Redission的分布式锁  --可以解决锁续命问题。
> 原理：利用锁的可重入特性，让获得锁的线程开启一个定时器的守护线程，每 expireTime/3 执行一次，去检查该线程的锁是否存在，如果存在则对锁的过期时间重新设置为 expireTime，即利用守护线程对锁进行“续命”，防止锁由于过期提前释放。  

2. 基于Redis多机的分布式锁方案：Redlock  

参考阅读：https://www.infoq.cn/article/DVAAJ71F4fBQsxmGVdCE  

