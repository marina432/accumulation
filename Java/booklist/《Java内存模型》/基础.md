### 一、并发模型的分类  
1. 并发模型需要处理的两个关键性问题：
- 线程之间如何通信？  
  > 通信，指线程之间以何种机制来交换信息。  
  > 在命令式编程中，线程之间的通信机制有两种：1.共享内存；2.消息传递。
  >> 1.在共享内存的并发模型中，线程之间共享内存的公共状态，线程之间通过读/写内存中的公共状态来隐式地尽心通信。  
  >> 2.在消息传递的并发模型中，线程必须通过明确的发送消息来显式进行通信。  
  
- 线程之间如何同步？  
  > 同步，指程序用于控制不同线程之间操作发生的相对顺序的机制。  
  >> 1.在共享内存并发模型中，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。   
  >> 2.在消息传递并发模型中，由于消息的发送必须在消息的接收之前，所以，同步是隐式的。  

Java采用共享内存并发模型，因此具有"隐式通信，显式同步"的特性。  
### 二、Java内存模型的抽象  
Java内存模型的作用：   
Java线程之间的通信是通过Java内存模型（JMM）来控制的。JMM决定来一个线程对共享内存的写入何时对另一个线程可见。  
JMM是语言级的内存模型，它确保在不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重排序与处理器冲排序，
为程序员提供一致的内存可靠性保证。  
> 从抽象角度来看，JMM定义了线程和主内存之间的抽象关系：  
> 线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory，亦称"工作内存"），
> 本地内存存储了该线程可以读/写的共享变量的副本。
>> ps：本地内存是JMM的一个抽象概念，涵盖：
>> 1.缓存 --影响共享变量的可见性  
>> 2.写缓冲区 --影响共享变量的可见性   
>> 3.寄存器以及其它硬件和编译器优化。--重排序，影响操作的顺序性

> ps：线程并发问题的三个源头：  
> - 原子性     --线程切换导致  
> - 可见性     --缓冲导致  
> - 顺序性     --重排序导致  

### 三、重排序  
分类（两大类三小类）  
1. 编译器重排序  
2. 处理器重排序  
    - 指令级并行重排序  
    - 内存系统冲排序  
    
> JMM作为语言级内存模型，为了提供一致的内存可靠性保证。  
> JMM的编译器重排序规则会禁止特定类型的编译器重排序。  
> JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障（memory barrier）指令，通过
> 内存屏障指令来禁止特定类型的处理器重排序。  


#### 3.1 处理器冲排序与内存屏障指令  



### 四、happens-before  
从JDK5开始，Java开始使用新的JSR-133内存模型。  
JSR-133使用happens-before的概念来阐述操作之间的内存可见性。happens-before规则简单易懂，它避免来Java程序员
为了理解JMM提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。 

参看:[happens-before](2.happens-before与volatile+synchronized+final.md)
   
