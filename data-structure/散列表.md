### 一、结构定性  
散列表是由数组演化而来，是数组的一种扩展，核心思想就是要利用数组数组支持下标随机访问数据的特性。没有数组，就没有散列表。  
实现方式：借助散列函数，将元素的键值映射为数组下标，然后将相应的数据存储在数组中对应下标的位置。  

### 二、散列函数设计  
#### 2.1 散列函数设计的基本要求  
1. 计算得到的散列值是一个非负整数；
2. 如果key1 = key2，那hash(key1) = hash(key2);
3. 如果key1 != key2, 那hash(key1) != hash(key2).  --这点几乎不可能做到，哈希冲突是无法避免的！  
ps：散列函数设计的好坏，决定了散列冲突的概率，也就决定了散列表的性能。 
   
2.2 如何设计散列函数？
1. 散列函数不能设计得太复杂。（过于复杂得散列函数，势必会消耗很多得计算时间，进而间接影响散列表性能）  
2. 散列函数生成得值要尽可能随机并且均匀分布。  
实际工作中，要综合考虑各种因素，包括：关键字得长、特点、分布、散列表得大小等。可以了解以下几种散列函数的设计方法：  
    - 数据分析法  
    - 直接寻址法
    - 平方取中法
    - 折叠法  
    - 随机数法  
    
### 三、哈希（散列）冲突解决方案  
#### 1. 开放寻址法（受限于散列表内解决）  
核心思想：如果出现了散列冲突，则（在散列表中）重新探测一个空闲位置，将其插入。  
三种探测方法：  
- 线性探测（探测步长固定为1）   --ps：Java的ThreadLocalMap使用此法解决散列冲突  
- 二次探测（探测步长依次为1*1, 2*2, 3*3, ...）  
- 双重散列（依次使用多个散列函数，知道找到空闲位置插入为止）  
另：确定使用开放寻址法解决散列冲突的方案后，务必要明确：删除操作不能真删（否则查找时可能误报"不存在"），要借助删除标记实现假删。  
  
开放寻址法，无论采用哪种探测方法，当散列表中空闲位置不多时，散列冲突的概率就会大大提高。为了尽可能保证散列摆哦的操作效率，就需要尽可能保证散列表中有一定比例的空闲槽位，可以了解一下装载因子（load factor）：  
> 散列表装载因子 = 填入表中的元素个数 / 散列表的长度  
> ps：装载因子越大，空闲位置越少，则冲突越多，散列表相关操作的性能就会下降。

#### 2. 链表法  
数组+链表  
链表实际存储数据

### 四、如何选择散列冲突解决方案？  
#### 1. 开放寻址法优、缺点及适用场景  
- 优点：散列表中的数据都存储在数组中，可以有效利用CPU缓存加快查询速度。而且这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来没那么容易。  
- 缺点：删数据比较麻烦，需要特殊标记已经删除掉的数据。所有数据都存储在一个数组中，冲突都代价更高。使用开放寻址法解决冲突都散列表，装载因子上限不能太大，因此也导致其比链表法更浪费内存空间。  
- 适用场景：适用于数据量比较小、装载因子小都时候。这也是Java中ThreadLocalMap使用开放寻址法解决散列冲突的原因。  

#### 2. 链表法优、缺点及适用场景  
- 优点：1.链表法对内存对利用率比开放寻址法要高。（即：按需申请，这也是链表优于数组对地方）2.比起开放寻址法，其对大装载因子对容忍度更高。
- 缺点：1.链表由于要存储指针，所以对较小的对象的存储是比较消耗内存的，甚至有可能让内存的消耗翻倍。（如果存储的是大对象，那指针的内存消耗在大对象面前就可以忽略了）2.由于链表中的节点是零散分布在内存中的，不是连续的，所以对CPU的缓存是不友好的，这对执行效率也有一定影响。
- 适用场景：适用于存储大对象、大数据量的散列表。而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树、跳表代替链表。

### 五、动态扩容  
当装载因子大到一定程度后，散列冲突就会变得不可接受。这时我们就要针对散列表进行动态扩容。  
针对散列表的扩容，数据搬移操作有些复杂。因为散列表的大小变化，数据的存储位置也将变更，所以需要通过散列函数重新计算每个数据的存储位置。  
#### 如何避免低效扩容  
为了解决一次性扩容耗时过多的情况，可以将扩容操作穿插在插入操作的过程中，分批完成，具体处理方案如下：
- 当装载因子触达阈值后，只申请新空间，但并不将老的数据搬移到新散列表中。  
- 当有新数据要插入时，直接将新数据插入新散列表中，并且从旧散列表中取出一个数据放入到新散列表中。（即：一新带一旧，以逐渐搬空旧散列表）将一次性扩容的代价，均摊到多次插入操作中，从而避免一次性扩容耗时过多的情况。  
- 这期间的查询操作，为了兼容新、老散列表中的数据，采取"先从新散列表中查找，如果没有，再去旧的散列表中查找"。  


### 六、分析工业级散列表HashMap  
运用以上内容，从以下几方面来分析HashMap作为工业级散列表是如何设计的：  
1. 初始大小  
HashMap的默认初始大小为16。如果能事先知道（即将涉及的）大概的数据量，创建时建议修改默认初始大小，以减少动态扩容的次数。这样会大大提高HashMap的性能。  
   
2. 装载因子和动态扩容  
HashMap的最大装载因子默认是0.75，当达到这个阈值时，就会启动自动扩容，每次扩容后容量都会扩大到原来都两倍。  
   
3. 散列冲突解决方案  
采用链表法解决散列冲突。这里要说：即使装载因子和散列函数设计得再合理，也免不了出现拉链过长都情况，而一旦出现拉链过长（极端情况退化成单链表），就会严重影响HashMap的性能。
   于是，从JDK1.8开始，HashMap引入了红黑树。当链表长度太长（默认超过8）时，链表就转为红黑树。
   而当红黑树节点个数少于8个时，又会将红黑树转为链表。（因为在数据量小的情况下，红黑树要维持平衡，比起链表来，性能上的优势并不明显。）  
   
4. 散列函数
HashMap的散列函数设计并不复杂，追求简单高效、分布均匀。
```java
/*
    int hash(Object key) {
        int h = key.hashCode();
        return (h ^ (h >>> 16)) & (capitity -1); //capicity 表示散列表的大小
    }
*/
```  


### 七、算列表与链表联合使用优化案例  
#### 7.1 散列表+双向链表优化"链表实现的LRU缓存淘汰算法"  
用双向链表存储数据，双向链表节点结构：  
- 数据（data）  
- 前驱指针（prev）  
- 后继指针（next）  
- 散列表拉链的hnext指针  

使用散列表+双向链表组合机构优化LRU缓存淘汰算法后，如何做到查询、删除、插入的时间复杂度都为O(1)的？  
1. 如何在缓存中查找一个数据？  
借助散列表，可以在时间复杂度为O(1)里快速查找数据，找到后，将其移动到双向链表的尾部。  
   
2. 如何从缓存中删除一个数据？  
借助散列表，在时间复杂度为O(1)里找到要删除的节点，利用双向列表节点的前驱、后继指针，在时间复杂度为O(1)里删除该节点。  
   
3. 如何向缓存中添加一个数据？  
首先，借助散列表查找该数据是否已在缓存中。如果是，则将其移动到双向链表的尾部。  
   如果不再缓存中，则接下来需要判断缓存是否已满。  
   如果缓存已满，则将双向链表表头的节点删除，然后将数据放到双向连标尾部。如果缓存未满，则直接将数据放到双向链表尾部即可。  


#### 7.2 散列表+跳表实现Redis有序集合的部分功能  
ps：跳表是（结构进一步优化的）双向链表
Redis中有序集合，  
  - 按照分值构建跳表，可以实现按分值维度的（有序要求）的操作  
  - 按照键值构建散列表，可以实现按键值快速查询、删除（无序要求）的操作

#### 7.3 LinkedHashMap  
LinkedHashMap支持两种方式便利数据：  
- 按照插入顺序遍历数据（默认，accessOrder = false）  
- 按照访问数据便利数据（accessOrder = true）  --类LRU缓存淘汰策略，且实现原理一样  
LinkedHashMap之所以有这样的特性，是因为LinkedHashMap是通过双向链表和散列表这两种数据结构组合实现的



#### 总结：为何散列表和链表经常一起使用？  
散列表这种数据结构虽然支持非常高效的数据插入、删除、查询操作，但是散列表中但数据都是通过散列函数打乱之后无规律存储的，因此，它无法支持按照某种顺序快速地遍历数据。
如果需要按照顺序遍历散列表中的数据，就需要将散列表中的数据拷贝到数组中，借助数组排序后，再遍历输出。
但是，散列表是动态数据结构，不停地插入删除是常态，而每次借助拷贝到数组实现顺序遍历势必效率很低。所以为了解决这个问题，就将散列表与链表（或跳表）结合在一起使用。


以上只是大概脉络，便于复习，具体可参考阅读：《数据结构与算法之美》--第18、19、20章
检测阅读：https://blog.csdn.net/cpongo1/article/details/89023332
